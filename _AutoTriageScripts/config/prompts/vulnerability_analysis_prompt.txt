Analyze this security vulnerability:

Vulnerability Information:
{vulnerability}

{tools_documentation}

IMPORTANT: Your investigation should follow this pattern:
1. FIRST: Generate search terms from the vulnerability (package name, CVE ID, vulnerability type, affected component) and call search_known_issues to find related human reviews
2. Review search results: If you find matches with high relevance scores (>5.0), call check_known_issue on the most relevant match to read the FULL details
3. If human review found: Read their complete reasoning, context, and evidence. Build upon their decision in your analysis
4. If no relevant reviews: Gather information using available tools (check_import_usage, search_code, search_sbom, read_file, etc.)
5. Once you have enough evidence (typically after 2-3 tool calls), call provide_analysis to conclude
6. ONLY use the tools listed in the documentation - do not invent new tools

Generating search terms:
- Include package/library name (e.g., "PyYAML", "Docker")
- Include vulnerability type (e.g., "code execution", "version tag")
- Include key concepts (e.g., "transitive dependency", "not used", "false positive")
- Use 3-5 specific terms that would appear in human reasoning

When human context exists:
- Acknowledge their decision and reasoning in your analysis
- Your investigation should verify or build upon their findings
- If you disagree with their assessment, explain why with specific evidence
- Include their context in your investigation_summary

When calling provide_analysis, you MUST assess the REAL WORLD severity:
- CRITICAL: Actively exploitable vulnerability that could lead to data breach, RCE, authentication bypass
- HIGH: Exploitable vulnerability with significant impact (data exposure, privilege escalation)
- MEDIUM: Potential security issue that requires specific conditions to exploit
- LOW: Minor security concern or dependency hygiene issue
- TRIVIAL: No real security impact, unused dependencies, cosmetic issues

Be realistic - if a vulnerable library is present but never imported or used, the severity is LOW or TRIVIAL, not the original CVE severity.

When providing your analysis, you MUST include:
- investigation_summary: Brief summary of what you investigated and how you reached your conclusion
- verification_steps: Specific, executable commands that the user can run
- limitations: What you couldn't check or potential gaps in your analysis

================================================================================
CRITICAL: FILE PATH REQUIREMENTS (READ THIS CAREFULLY)
================================================================================

EVERY TIME you mention a file, directory, or command in ANY of these fields:
- investigation_summary
- verification_steps  
- recommended_actions
- evidence

You MUST use the FULL FILE PATH from the 'component' field.

HOW TO EXTRACT THE FULL PATH:
1. Look at the 'component' field in the vulnerability data
2. Remove the project prefix (e.g., "AutoTriage:") if present
3. Use the remaining path exactly as-is

EXAMPLES OF CORRECT vs INCORRECT FILE REFERENCES:

CORRECT (Always do this):
  - "Examined container_security/vulnerable/Dockerfile line 16"
  - "Run: grep 'ENV DB_PASSWORD' container_security/vulnerable/Dockerfile"
  - "Check old_deps/requirements.txt for Flask version"
  - "Inspect container_security/app/app.py line 42"
  - "docker build -f container_security/vulnerable/Dockerfile ."

INCORRECT (Never do this):
  - "Examined Dockerfile line 16" (Missing path!)
  - "Run: grep 'ENV' Dockerfile" (Which Dockerfile?)
  - "Check requirements.txt for Flask" (Which requirements.txt?)
  - "Inspect app.py line 42" (Which app.py?)
  - "docker build ." (Which Dockerfile?)

VERIFICATION STEPS - MUST BE COPY-PASTEABLE:
Your verification steps must be commands the user can copy and paste directly into their terminal.

CORRECT:
  - "grep -n 'debug=True' container_security/app/app.py"
  - "docker history $(docker build -q -f container_security/vulnerable/Dockerfile .)"
  - "python -c 'import sys; sys.path.insert(0, \"old_deps\"); import yaml; print(yaml.__version__)'"

INCORRECT:
  - "grep for debug=True in the app file" (Not executable!)
  - "Check the docker history" (Not a command!)
  - "Verify Python imports" (Too vague!)

NO VAGUE STATEMENTS ALLOWED:
BAD:  "Check the Dockerfile for secrets"
GOOD: "Check container_security/vulnerable/Dockerfile lines 16-17 for ENV instructions containing DB_PASSWORD and AWS_ACCESS_KEY"

BAD:  "Verify the app is not deployed with debug mode"
GOOD: "Check if container_security/app/app.py is deployed in production with 'grep -r \"debug=True\" container_security/'"

BAD:  "Look for usage of the vulnerable function"
GOOD: "Search for yaml.full_load() usage with: grep -r 'yaml\.full_load' container_security/"

EVERY file reference, EVERY command, EVERY path â†’ MUST BE COMPLETE AND SPECIFIC.

FINAL CHECKLIST BEFORE CALLING provide_analysis:
[ ] Every file mentioned has its FULL path (e.g., container_security/app.py)
[ ] Every command is copy-pasteable and includes full paths
[ ] No vague statements like "check the file" or "verify the config"
[ ] verification_steps are actual shell commands, not descriptions
[ ] investigation_summary explains exactly which files/lines were examined

Start by calling search_known_issues with relevant terms, then proceed with investigation. You can include 'reasoning' in any tool call to organize your thoughts.

