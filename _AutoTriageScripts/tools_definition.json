{
  "tools": [
    {
      "name": "read_file",
      "description": "Read the complete contents of a file from the workspace",
      "parameters": {
        "file_path": {
          "type": "string",
          "description": "Path to the file relative to workspace root (e.g., 'container_security/app/app.py')",
          "required": true
        }
      },
      "returns": {
        "success": "boolean - whether the file was read successfully",
        "file_path": "string - the file path that was read",
        "content": "string - full file contents",
        "lines": "integer - number of lines in file",
        "error": "string - error message if success is false"
      },
      "example": {
        "call": {
          "tool": "read_file",
          "parameters": {
            "file_path": "container_security/app/app.py"
          }
        },
        "response": {
          "success": true,
          "file_path": "container_security/app/app.py",
          "content": "from flask import Flask...",
          "lines": 43
        }
      }
    },
    {
      "name": "read_file_lines",
      "description": "Read a specific range of lines from a file (useful for large files)",
      "parameters": {
        "file_path": {
          "type": "string",
          "description": "Path to the file relative to workspace root",
          "required": true
        },
        "start_line": {
          "type": "integer",
          "description": "Starting line number (1-indexed)",
          "required": true
        },
        "end_line": {
          "type": "integer",
          "description": "Ending line number (inclusive)",
          "required": true
        }
      },
      "returns": {
        "success": "boolean",
        "file_path": "string",
        "start_line": "integer",
        "end_line": "integer",
        "content": "string - the requested lines",
        "total_lines": "integer - total lines in file",
        "error": "string"
      },
      "example": {
        "call": {
          "tool": "read_file_lines",
          "parameters": {
            "file_path": "container_security/vulnerable/Dockerfile",
            "start_line": 1,
            "end_line": 10
          }
        }
      }
    },
    {
      "name": "search_code",
      "description": "Search for a pattern in the codebase using grep. Returns matching lines with file paths and line numbers.",
      "parameters": {
        "pattern": {
          "type": "string",
          "description": "The pattern to search for (supports regex)",
          "required": true
        },
        "file_glob": {
          "type": "string",
          "description": "Optional glob pattern to limit search (e.g., '*.py', '*.txt'). Default: all files",
          "required": false,
          "default": "*"
        },
        "case_sensitive": {
          "type": "boolean",
          "description": "Whether search should be case-sensitive",
          "required": false,
          "default": false
        }
      },
      "returns": {
        "success": "boolean",
        "pattern": "string - the pattern searched",
        "matches": "array - list of matches",
        "match_count": "integer - total matches found",
        "error": "string"
      },
      "example": {
        "call": {
          "tool": "search_code",
          "parameters": {
            "pattern": "import yaml|from yaml",
            "file_glob": "*.py"
          }
        },
        "response": {
          "success": true,
          "pattern": "import yaml|from yaml",
          "matches": [
            {
              "file": "container_security/app/parser.py",
              "line_number": 5,
              "line_content": "import yaml",
              "context": ["# Parse configuration", "import yaml", "import json"]
            }
          ],
          "match_count": 1
        }
      }
    },
    {
      "name": "list_directory",
      "description": "List files and subdirectories in a directory",
      "parameters": {
        "directory": {
          "type": "string",
          "description": "Directory path relative to workspace root. Use '.' for workspace root",
          "required": true
        },
        "recursive": {
          "type": "boolean",
          "description": "Whether to list recursively",
          "required": false,
          "default": false
        }
      },
      "returns": {
        "success": "boolean",
        "directory": "string",
        "files": "array - list of files",
        "directories": "array - list of subdirectories",
        "error": "string"
      },
      "example": {
        "call": {
          "tool": "list_directory",
          "parameters": {
            "directory": "container_security",
            "recursive": false
          }
        }
      }
    },
    {
      "name": "find_files",
      "description": "Find files matching a pattern (like 'find' command)",
      "parameters": {
        "pattern": {
          "type": "string",
          "description": "Filename pattern to match (e.g., 'requirements*.txt', '*.py')",
          "required": true
        },
        "directory": {
          "type": "string",
          "description": "Directory to search in (relative to workspace root). Default: entire workspace",
          "required": false,
          "default": "."
        }
      },
      "returns": {
        "success": "boolean",
        "pattern": "string",
        "files": "array - list of matching file paths",
        "count": "integer",
        "error": "string"
      },
      "example": {
        "call": {
          "tool": "find_files",
          "parameters": {
            "pattern": "requirements*.txt"
          }
        },
        "response": {
          "success": true,
          "pattern": "requirements*.txt",
          "files": ["container_security/requirements.txt", "old_deps/requirements.txt"],
          "count": 2
        }
      }
    },
    {
      "name": "search_sbom",
      "description": "Search the SBOM (Software Bill of Materials) for package information",
      "parameters": {
        "package_name": {
          "type": "string",
          "description": "Name of package to search for (case-insensitive)",
          "required": true
        }
      },
      "returns": {
        "success": "boolean",
        "package_name": "string",
        "found": "boolean - whether package was found in SBOM",
        "component": "object - package details if found",
        "error": "string"
      },
      "example": {
        "call": {
          "tool": "search_sbom",
          "parameters": {
            "package_name": "PyYAML"
          }
        },
        "response": {
          "success": true,
          "package_name": "PyYAML",
          "found": true,
          "component": {
            "name": "PyYAML",
            "version": "5.3.1",
            "purl": "pkg:pypi/pyyaml@5.3.1",
            "licenses": ["MIT"]
          }
        }
      }
    },
    {
      "name": "check_import_usage",
      "description": "Check if a Python package is imported anywhere in the codebase",
      "parameters": {
        "package_name": {
          "type": "string",
          "description": "Name of the Python package (e.g., 'yaml', 'flask', 'requests')",
          "required": true
        }
      },
      "returns": {
        "success": "boolean",
        "package_name": "string",
        "is_imported": "boolean - whether package is imported",
        "import_locations": "array - files where package is imported",
        "import_patterns": "array - the actual import statements found",
        "error": "string"
      },
      "example": {
        "call": {
          "tool": "check_import_usage",
          "parameters": {
            "package_name": "yaml"
          }
        },
        "response": {
          "success": true,
          "package_name": "yaml",
          "is_imported": false,
          "import_locations": [],
          "import_patterns": []
        }
      }
    },
    {
      "name": "provide_analysis",
      "description": "Provide the final analysis conclusion. This MUST be called when you have gathered enough information to make a determination. This ends the analysis loop.",
      "parameters": {
        "is_applicable": {
          "type": "boolean",
          "description": "Whether the reported issue actually applies to this project",
          "required": true
        },
        "confidence": {
          "type": "number",
          "description": "Confidence in the analysis from 0.0 (no confidence) to 1.0 (absolute certainty)",
          "required": true,
          "minimum": 0.0,
          "maximum": 1.0
        },
        "real_severity": {
          "type": "string",
          "description": "The ACTUAL real-world severity based on your investigation. Valid values: CRITICAL (data breach, RCE, authentication bypass), HIGH (exploitable vulnerabilities, data exposure), MEDIUM (potential security issues, performance problems), LOW (code quality, best practices), TRIVIAL (cosmetic issues, style preferences). Be honest about real-world impact - most code quality issues are TRIVIAL or LOW.",
          "required": true,
          "enum": ["CRITICAL", "HIGH", "MEDIUM", "LOW", "TRIVIAL"]
        },
        "explanation": {
          "type": "string",
          "description": "Detailed explanation of your reasoning and what evidence you found (this will be shown to users)",
          "required": true
        },
        "evidence": {
          "type": "object",
          "description": "Structured evidence supporting your conclusion (e.g., files checked, patterns found, etc.)",
          "required": true
        },
        "recommended_actions": {
          "type": "array",
          "description": "List of recommended actions for developers",
          "items": {
            "type": "string"
          },
          "required": true
        }
      },
      "returns": {
        "status": "analysis_complete"
      },
      "example": {
        "call": {
          "tool": "provide_analysis",
          "parameters": {
            "is_applicable": false,
            "confidence": 0.9,
            "real_severity": "LOW",
            "explanation": "PyYAML 5.3.1 is listed in requirements.txt but after searching the entire codebase, no import statements for yaml were found. The vulnerable functions (full_load, FullLoader) are not used.",
            "evidence": {
              "in_requirements": true,
              "requirements_file": "container_security/requirements.txt",
              "import_found": false,
              "files_searched": ["*.py"],
              "search_patterns_tried": ["import yaml", "from yaml", "yaml.full_load", "FullLoader"]
            },
            "recommended_actions": [
              "Remove PyYAML from requirements.txt if it's truly unused",
              "If PyYAML is needed for future use, upgrade to version >= 5.4",
              "Verify no dynamic imports or indirect usage of PyYAML"
            ]
          }
        }
      }
    }
  ],
  "tool_call_format": {
    "description": "When you want to use a tool, respond with ONLY a JSON object in this exact format",
    "format": {
      "tool": "string - name of the tool from the list above",
      "parameters": "object - parameters required by the tool",
      "reasoning": "string (OPTIONAL) - your internal thoughts/reasoning for this step. This is for your own use and will be saved but not used by the system. Use it as a scratchpad to organize your thinking."
    },
    "example": "{\n  \"tool\": \"search_code\",\n  \"parameters\": {\n    \"pattern\": \"import yaml\",\n    \"file_glob\": \"*.py\"\n  },\n  \"reasoning\": \"Checking if yaml package is actually imported in the codebase\"\n}"
  },
  "important_notes": [
    "You can only call ONE tool per message",
    "Always wait for the tool result before deciding on the next step",
    "Be strategic - think about what information you need before calling tools",
    "Once you have sufficient evidence, call provide_analysis to complete the analysis",
    "If you're unsure after 3-4 tool calls, provide your best analysis with lower confidence",
    "Always provide specific file paths and line numbers in your evidence"
  ]
}
